/*
Copyright 1999-2011 (c) My-Channels
Copyright (c) 2012-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.

Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG.
*/

package com.pcbsys.nirvana.nJMSApps;

import com.pcbsys.foundation.utils.fEnvironment;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Hashtable;

import javax.jms.*;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;

/**
 * This class demonstrates how to construct a Publisher that can send messages on either a topic or queue,
 * based on the type of the connection factory provided as parameters
 */
public class Publisher implements ExceptionListener {
  // static public String sClassVersion = "$Name: nirvana_9_6 $ - $Revision: 1.22 $";

  private final Object mutex = new Object();
  protected MessageProducer p;
  protected Session s;
  protected int publishCount = 0;

  public static void main(String[] args) {
    //Check to see if args were specified
    if ((args.length == 1) && args[0].equals("-?")) {
      UsageEnv();
    }

    if (args.length < 2) {
      Usage();
      System.exit(1);
    }

    //Process Environment Variables
    processEnvironmentVariable("RNAME");
    processEnvironmentVariable("PRINCIPAL");
    processEnvironmentVariable("PASSWORD");
    processEnvironmentVariable("CONTEXT_FACTORY");
    processEnvironmentVariable("PROVIDER_URL");
    processEnvironmentVariable("LOGLEVEL");
    processEnvironmentVariable("HPROXY");
    processEnvironmentVariable("HAUTH");
    processEnvironmentVariable("CKEYSTORE");
    processEnvironmentVariable("CKEYSTOREPASSWD");
    processEnvironmentVariable("CAKEYSTORE");
    processEnvironmentVariable("CAKEYSTOREPASSWD");

    // Install any proxy server settings
    fEnvironment.setProxyEnvironments();

    // Install any ssl settings
    fEnvironment.setSSLEnvironments();

    //Create an instance for this class
    Publisher publisher = new Publisher();

    int count = 10000;
    boolean transacted = false;

    if (args.length > 2) {
      count = Integer.parseInt(args[2]);
    }

    if (args.length > 3) {
      transacted = Boolean.parseBoolean(args[3]);
    }

    //Publish to the topic specified
    publisher.doIt(args[0], args[1], count, transacted);
  }

  protected static void UsageEnv() {
    System.out.println("\n\n(Environment Variables) \n");

    System.out.println("(RNAME) - One or more RNAME entries in the form protocol://host:port");
    System.out.println("   protocol - Can be one of nsp, nhp, nsps, or nhps, where:");
    System.out.println("   nsp - Specifies Nirvana Socket Protocol (nsp)");
    System.out.println("   nhp - Specifies Nirvana HTTP Protocol (nhp)");
    System.out.println("   nsps - Specifies Nirvana Socket Protocol Secure (nsps), i.e. using SSL/TLS");
    System.out.println("   nhps - Specifies Nirvana HTTP Protocol Secure (nhps), i.e. using SSL/TLS");
    System.out.println("   port - The port number of the server");
    System.out.println("\nHint: - For multiple RNAME entries, use comma separated values which will be attempted in connection weight order\n");

    System.out.println("(ISTRANSACTED) - This determines if publishing will be transacted (default: false)\n");
    System.out.println("(LOGLEVEL) - This determines how much information the nirvana api will output 0 = verbose 7 = quiet\n");

    System.out.println("(CKEYSTORE) - If using SSL, the location of the keystore containing the client cert\n");
    System.out.println("(CKEYSTOREPASSWD) - If using SSL, the password for the keystore containing the client cert\n");
    System.out.println("(CAKEYSTORE) - If using SSL, the location of the ca truststore\n");
    System.out.println("(CAKEYSTOREPASSWD) - If using SSL, the password for the ca truststore\n");

    System.out.println("(HPROXY) - HTTP Proxy details in the form proxyhost:proxyport, where:");
    System.out.println("   proxyhost - The HTTP proxy host");
    System.out.println("   proxyport - The HTTP proxy port\n");
    System.out.println("(HAUTH) - HTTP Proxy authentication details in the form user:pass, where:");
    System.out.println("   user - The HTTP proxy authentication username");
    System.out.println("   pass - The HTTP proxy authentication password\n");
  }

  /**
   * This method is the callback for any exception generated by the JMS provider
   *
   * @param ex the JMSException thrown
   */
  public void onException(JMSException ex) {
    ex.printStackTrace();
  }

  /**
   * Get the initial context used to locate the factories and destinations
   *
   * @return the initial context based on the supplied PROVIDER_URL
   * @throws Exception if contex cannot be created
   */
  protected Context getInitialContext() throws Exception {
    Hashtable<String,String> env = new Hashtable<String,String>();
    env.put(Context.INITIAL_CONTEXT_FACTORY, System.getProperty("CONTEXT_FACTORY", "com.pcbsys.nirvana.nSpace.NirvanaContextFactory"));
    String rname = System.getProperty("RNAME");

    if (rname == null) {
      env.put(Context.PROVIDER_URL, System.getProperty("PROVIDER_URL", "nsp://127.0.0.1:9000"));
    } else {
      env.put(Context.PROVIDER_URL, System.getProperty("PROVIDER_URL", rname));
    }
    env.put(Context.SECURITY_AUTHENTICATION, "simple");
    env.put(Context.SECURITY_PRINCIPAL, System.getProperty("PRINCIPAL", "simple"));
    env.put(Context.SECURITY_CREDENTIALS, System.getProperty("PASSWORD", "simple"));

    return new InitialContext(env);
  }

  /**
   * Get the destination from the context, if not bound, then bind it
   *
   * @param ctx      the context to use
   * @param s        the session used to create the destination if it is not bound
   * @param destName the name of the destination
   * @return the desired topic
   */
  protected Destination getDestination(Context ctx, Session s, String destName) {
    Destination d = null;

    try {
      d = (Destination) ctx.lookup(destName);
    } catch (NamingException e) {
      try {
        if (s instanceof TopicSession) {
          d = s.createTopic(destName);
        } else {
          d = s.createQueue(destName);
        }
        ctx.bind(destName, d);
      } catch (Exception e1) {
        e1.printStackTrace();
      }
    }
    return d;
  }

  /**
   * This method demonstrates the Nirvana JMS API calls necessary to publish to
   * a destination whether it is a topic or a queue.
   * It is called after all command line arguments have been received and
   * validated
   *
   * @param factoryName The name of the factory to find
   * @param destName    the name of the destination
   * @param count       number of message to publish
   * @param transacted  whether the session is transactional
   */
  private void doIt(String factoryName, String destName, int count, boolean transacted) {
    try {
      // get the initial context
      Context ctx = getInitialContext();
      ConnectionFactory cf = (ConnectionFactory) ctx.lookup(factoryName);

      // Create a Connection from the Connection Factory
      Connection c = cf.createConnection();

      // set the exceptionlistener
      c.setExceptionListener(this);

      // Start the connection
      c.start();

      // Create a Sesson from the Connection
      s = c.createSession(transacted, 1);

      // create the destination, and bind if necessary
      Destination d = getDestination(ctx, s, destName);

      //Create a Producer from the Session
      p = s.createProducer(d);

      //Prompt for a message
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in), 1);
      System.out.print("Enter a message to be published : ");

      String str = br.readLine();

      // create a bytes message
      TextMessage bmsg = s.createTextMessage();
      bmsg.setText(str);

      //Loop for count
      for (int x = 0; x < count; x++) {
        if (transacted) {
          doTXPublish(bmsg);
        } else {
          doPublish(bmsg);
        }
      }

      //Print a message to the console saying we are about to exit
      System.out.println("Closing session and connection. Published a total of " + publishCount + " messages");
      Thread.sleep(1000);
      c.close();
      s.close();

      //close the context
      ctx.close();
    } catch (NamingException ex) {
      System.out.println("\nNaming Exception : Please ensure you have created the connection factory " + factoryName);
      System.out.println("Naming Exception : This can be done using the Enterprise Manager JNDI panel or the jmsadmin command line application");
      ex.printStackTrace();
    } catch (Exception ex) {
      ex.printStackTrace();
    }
  }

  public void doTXPublish(Message msg) {
	  boolean success = false;
	  while (!success) {
		  try {
			  p.send(msg);
			  success = true;
		  } catch (Throwable t) {
			  System.out.println("JMS-Producer send failed - "+t);
			  synchronized (mutex) {
				  try {
					  mutex.wait(5);
				  } catch (InterruptedException ignored) {}
			  }
		  }
	  }
	  success = false;
	  while (!success) {
		  try {
			  s.commit();
			  success = true;
			  publishCount++;
			  synchronized (mutex) {
				  mutex.wait(10); //NB: Modify or comment this out, to change the throttling level
			  }
		  } catch (Throwable t) {
			  System.out.println("JMS-Producer commit failed - "+t);
			  try {
				  synchronized (mutex) {
					  mutex.wait(500);
				  }
			  } catch (InterruptedException ignored) {}
		  }
	  }
  }

  public void doPublish(Message msg) {
    try {
      //Publish the message to the topic
      p.send(msg);
      publishCount++;
    } catch (JMSException e) {
      e.printStackTrace();
      boolean committed = false;

      while (!committed) {
        try {
          p.send(msg);
          committed = true;
        } catch (JMSException ex) {
          try {
            Thread.sleep(1000);
          } catch (InterruptedException ignored) {}
        }
      }
    }
  }

  /**
   * Prints the usage message for this class
   */
  private static void Usage() {
    System.out.println("Usage ...\n\n");
    System.out.println("jmspub <factoryname> <destinationName> <count> <transacted>\n");

    System.out.println("<Required Arguments> \n");
    System.out.println("<factoryname> - JMS Factory (Must exist in target realm)");
    System.out.println("<destinationName> - JMS Destination to publish on");
    System.out.println("<count> - Number of events to publish");
    System.out.println("<transacted> - Whether the session is transacted");
    System.out.println("\n\nNote: -? provides help on environment variables \n");
  }

  protected static void processEnvironmentVariable(String variable) {
    String laxVAR = System.getProperty("lax.nl.env." + variable);

    if (laxVAR != null) {
      System.getProperties().put(variable, laxVAR);
    }
  }
}
// End of Publisher Class
